<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Happy Birthday</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;background:#eb8787;font-family:Helvetica,Arial}
    #gameWrap{display:flex;flex-direction:column;align-items:center;padding:8px}
    canvas {
  background: linear-gradient(#e7fb8e,#bfe9ff);
  border: 4px solid #2b2b2b;
  border-radius: 8px;
  width: 90%;
  max-width: 960px;
  height: 100%;
  aspect-ratio: 1.9 / 0.9; /* maintains proper proportions */
  touch-action: none;
}
#hud{margin-top:8px;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button{padding:6px 10px;border-radius:6px;border:1px solid #333;background:#fff;cursor:pointer}
    input[type=file]{display:none}
    #message{font-weight:700;color:#2b2b2b}

    /* Mobile virtual buttons */
    #mobileControls {
  position: fixed;
  bottom: 5vh;
  left: 0;
  right: 0;
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  padding: 0 15vw;
  pointer-events: none;
}
.vbtn {
  width: 70px;
  height: 70px;
  border-radius: 50%;
  background: rgba(255,255,255,0.3);
  border: 2px solid #333;
  pointer-events: auto;
  touch-action: none;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 26px;
  color: #222;
  user-select: none;
}
#jumpBtn {
  position: static;
  margin-left: auto;
}
.vbtn {width:80px;height:80px;border-radius:50%;background:rgba(255,255,255,0.28);border:2px solid #333;pointer-events:auto;touch-action:none;display:flex;align-items:center;justify-content:center;font-size:28px;font-weight:bold;color:#333;margin:0 20px;user-select:none;}
    .vbtn:active {background:rgba(255,255,255,0.6);}
    #jumpBtn {position:fixed;bottom:20px;right:20px;width:90px;height:90px;}

    /* Score and timer */
    #scoreBoard{position:fixed;top:12px;left:12px;background:rgba(255,255,255,0.6);padding:6px 10px;border-radius:8px;font-weight:700}
  </style>
</head>
<body>
  <div id="gameWrap">
    <h2>:)))))))))))</h2>
    <canvas id="c" width="960" height="400"></canvas>

    <div id="hud">
      <button id="restart">Restart</button>
      <button id="toggleSound">Toggle Sound</button>
      <label style="display:flex;align-items:center;gap:6px">Change player sprite: <input id="spriteFile" type="file" accept="image/*"></label>
      <label style="display:flex;align-items:center;gap:6px">Change BG music: <input id="bgMusicFile" type="file" accept="audio/*"></label>
      <div id="message">Touch or use ‚Üê ‚Üí to move, ‚Üë or Space to jump</div>
      <button id="fullscreenBtn" style="display:none;">‚õ∂ Fullscreen</button>

    </div>
  </div>

  <div id="scoreBoard">Score: <span id="scoreValue">0</span> &nbsp; Time: <span id="timeValue">0.0</span>s</div>

  <!-- Mobile virtual controls -->
  <div id="mobileControls" style="display:none;">
    <div id="leftBtn" class="vbtn">‚óÄ</div>
    <div id="rightBtn" class="vbtn">‚ñ∂</div>
    <div id="jumpBtn" class="vbtn">‚§í</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
function resizeCanvas() {
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width;
  canvas.height = rect.height;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

  // ------------------ State ------------------
  let keys = {};
  let soundOn = true;
  let gameWon = false;
  let showCake = false;
  let score = 0;
  let timeElapsed = 0;

  // Player with double-jump
  const player = {
    x: 40, y: H-120, w: 28, h: 40,
    vx: 0, vy: 0, speed: 20.6, jumpPower: -50.5, grounded: false,
    jumpsUsed: 0, maxJumps: 2,
    sprite: null, spriteLoaded: false
  };

  // Parallax layers (simple) - move based on camera/player x
  const parallax = [
    {depth: 0.2, draw: drawFarMountains},
    {depth: 0.5, draw: drawNearHills},
    {depth: 0.8, draw: drawBushes}
  ];

  // Letter groups (HEL L Y) ‚Äî will be moving slowly as platforms
  const letterGroups = [];
  const baseLetterColor = 'orange';
  function makeLetterH(x,y,s){return[{x:x,y:y,width:16*s,height:120*s,ox:x,oy:y},{x:x+48*s,y:y,width:16*s,height:120*s,ox:x+48*s,oy:y},{x:x+16*s,y:y+48*s,width:40*s,height:16*s,ox:x+16*s,oy:y+48*s}];}
  function makeLetterE(x,y,s){return[{x:x,y:y,width:16*s,height:120*s,ox:x,oy:y},{x:x+16*s,y:y,width:48*s,height:16*s,ox:x+16*s,oy:y},{x:x+16*s,y:y+52*s,width:38*s,height:16*s,ox:x+16*s,oy:y+52*s},{x:x+16*s,y:y+104*s,width:48*s,height:16*s,ox:x+16*s,oy:y+104*s}];}
  function makeLetterL(x,y,s){return[{x:x,y:y,width:16*s,height:120*s,ox:x,oy:y},{x:x+16*s,y:y+104*s,width:48*s,height:16*s,ox:x+16*s,oy:y+104*s}];}
  function makeLetterY(x,y,s){return[{x:x,y:y,width:16*s,height:56*s,ox:x,oy:y},{x:x+40*s,y:y,width:16*s,height:56*s,ox:x+40*s,oy:y},{x:x+16*s,y:y+56*s,width:24*s,height:16*s,ox:x+16*s,oy:y+56*s},{x:x+28*s,y:y+72*s,width:16*s,height:48*s,ox:x+28*s,oy:y+72*s}];}

  const startX = 120; const baseY = 180; const scale = 1.6;
  letterGroups.push(...makeLetterH(startX, baseY, scale));
  letterGroups.push(...makeLetterE(startX+120, baseY, scale));
  letterGroups.push(...makeLetterL(startX+240, baseY, scale));
  letterGroups.push(...makeLetterL(startX+360, baseY, scale));
  letterGroups.push(...makeLetterY(startX+480, baseY, scale));

  // floor and end area
  const floor = {x:0,y:H-20,width:3000,height:20};
  const endX = startX + 640; const endArea = {x:endX,y:0,width:140,height:H};

  // moving platforms (example extra platform)
  const movingPlatforms = [
    {x: 400, y: H-150, width:40, height:14, ox:50, oy:H-150, range:50, speed:0.8, dir:1},
    {x: 900, y: H-220, width:100, height:14, ox:500, oy:H-250, range:80, speed:1.1, dir:1}
  ];

  // enemies
  const enemies = [
    {x: 320, y:H-100-285, w:28, h:28, vx:80, left:300, right:620},
    {x: 820, y:H-60-258, w:28, h:28, vx:66, left:380, right:660}
  ];

  // fireworks storage
  let fireworks = [];

  // confetti (kept)
  let confettiParticles = [];

  // audio
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  let masterGain = audioCtx.createGain(); masterGain.gain.value = 0.12; masterGain.connect(audioCtx.destination);
  let winSongBuffer = null;

  // Preload "song.mp3"
  fetch('song.mp3')
    .then(res => res.arrayBuffer())
    .then(buf => audioCtx.decodeAudioData(buf))
    .then(decoded => {
      winSongBuffer = decoded;
      console.log('Win song loaded and ready!');
    })
    .catch(err => console.error('Error loading song.mp3:', err));

  let bgOscNodes = []; let bgLoopTimeout; let customMusicBuffer=null; let customMusicSource=null;

  // default sprite
  const defaultSprite = new Image(); defaultSprite.src = ''; // left empty so rectangle fallback used
  player.sprite = null; player.spriteLoaded = false;

  // -------------- Input --------------
  window.addEventListener('keydown', e=>{ keys[e.code]=true; if(e.code==='Space') e.preventDefault(); });
  window.addEventListener('keyup', e=>{ keys[e.code]=false; });

  // UI controls
  document.getElementById('restart').addEventListener('click', ()=>{ resetGame(); });
  document.getElementById('toggleSound').addEventListener('click', ()=>{ soundOn = !soundOn; if(soundOn){ audioCtx.resume(); startBackgroundMusic(); } else { stopBackgroundMusic(); } document.getElementById('toggleSound').innerText = soundOn? 'Sound: ON' : 'Sound: OFF'; });

  // file inputs for sprite and music
  document.getElementById('spriteFile').addEventListener('change', ev=>{ const f = ev.target.files[0]; if(!f) return; const url = URL.createObjectURL(f); changePlayerSprite(url); });
  document.getElementById('bgMusicFile').addEventListener('change', async (ev)=>{ const f = ev.target.files[0]; if(!f) return; const array = await f.arrayBuffer(); customMusicBuffer = await audioCtx.decodeAudioData(array); console.log('Custom music loaded'); if(soundOn){ startBackgroundMusic(); } });

  // mobile virtual controls binding
  const mobileControls = document.getElementById('mobileControls');
  if('ontouchstart' in window) mobileControls.style.display = 'flex';
  if ('ontouchstart' in window) {
  document.getElementById('hud').style.display = 'none';
  document.querySelector('h2').style.display = 'none';
}
if('ontouchstart' in window){
  document.getElementById('fullscreenBtn').style.display = 'block';
  document.getElementById('fullscreenBtn').addEventListener('click', ()=>{
    if(canvas.requestFullscreen) canvas.requestFullscreen();
  });
}

  function bindTouch(btnId, keyCode){ const el = document.getElementById(btnId); el.addEventListener('touchstart', e=>{ e.preventDefault(); keys[keyCode]=true; }, {passive:false}); el.addEventListener('touchend', e=>{ e.preventDefault(); keys[keyCode]=false; }, {passive:false}); }
  bindTouch('leftBtn','ArrowLeft'); bindTouch('rightBtn','ArrowRight'); bindTouch('jumpBtn','Space');

  // -------------- Audio functions --------------
  function startBackgroundMusic(){
    if(!soundOn) return;
    stopBackgroundMusic();
    if(customMusicBuffer){
      customMusicSource = audioCtx.createBufferSource();
      customMusicSource.buffer = customMusicBuffer;
      customMusicSource.loop = true;
      customMusicSource.connect(masterGain);
      customMusicSource.start();
      return;
    }
    const now = audioCtx.currentTime;
    const melody = [440, 523.25, 659.25, 880, 659.25, 523.25];
    melody.forEach((freq, i) => {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'sine'; o.frequency.value = freq;
      g.gain.value = 0.01;
      o.connect(g); g.connect(masterGain);
      o.start(now + i*0.25);
      o.stop(now + i*0.25 + 0.22);
      bgOscNodes.push(o);
    });
    bgLoopTimeout = setTimeout(()=>{ if(soundOn) startBackgroundMusic(); }, melody.length*250 + 80);
  }
  function stopBackgroundMusic(){
    if(customMusicSource){ try{ customMusicSource.stop(); }catch(e){} customMusicSource = null; }
    if(bgLoopTimeout){ clearTimeout(bgLoopTimeout); bgLoopTimeout = null; }
    bgOscNodes.forEach(o=>{ try{o.stop();}catch(e){} }); bgOscNodes = [];
  }
  function playWinSound() {
  if (!soundOn) return;

  if (winSongBuffer) {
    // Stop background melody or loops first
    stopBackgroundMusic();

    // Play the song
    const source = audioCtx.createBufferSource();
    source.buffer = winSongBuffer;
    source.connect(masterGain);
    source.start();
  } else {
    // fallback sound if the song isn't loaded yet
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine';
    o.frequency.value = 880;
    g.gain.value = 0.03;
    o.connect(g);
    g.connect(masterGain);
    o.start();
    o.stop(audioCtx.currentTime + 0.6);
  }
}

  // -------------- Utilities --------------
  function rectsCollide(a,b){ return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y; }

  function changePlayerSprite(src){ const i = new Image(); i.onload = ()=>{ player.sprite = i; player.spriteLoaded = true; }; i.onerror = ()=>{ player.sprite = null; player.spriteLoaded = false; }; i.src = src; }
  window.changePlayerSprite = changePlayerSprite;

  function resetGame(){
    player.x = 40; player.y = H-120; player.vx = 0; player.vy = 0; player.grounded = false; player.jumpsUsed = 0;
    gameWon = false; showCake = false; timeElapsed = 0; score = 0; fireworks = []; confettiParticles = [];
    enemies[0].x = 520; enemies[1].x = 820; // reset enemies
    // reset letters to original positions
    letterGroups.forEach(l => { l.x = l.ox; l.y = l.oy; });
    // start music if enabled
    startBackgroundMusic();
  }

  // -------------- Fireworks & Confetti --------------
  function spawnConfetti(){ for(let i=0;i<60;i++){ confettiParticles.push({x: endX + 70 + Math.random()*120, y: 60 + Math.random()*200, vx: (Math.random()-0.5)*2.2, vy: Math.random()*1.8+0.8, r: Math.random()*4+2, c: ['#ff3b3b','#ffcd3c','#2bde73','#6bc6ff','#c27bff'][Math.floor(Math.random()*5)]}); } }

  // spawn one firework burst
  function spawnFirework(x, y, color){ const particles = []; const sparks = 20 + Math.floor(Math.random()*12); for(let i=0;i<sparks;i++){ const angle = Math.random()*Math.PI*2; const speed = Math.random()*4+1.5; particles.push({x, y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, life: 60 + Math.random()*40, c: color}); } fireworks.push(particles); }

  // spawn 27 fireworks across the sky
  function spawn27Fireworks(){ for(let i=0;i<27;i++){ const x = Math.random()*(W-200)+100; const y = Math.random()*(H*0.4)+40; const color = `hsl(${Math.random()*360},100%,60%)`; spawnFirework(x,y,color); } }

  function updateFireworks(){ fireworks.forEach((fw, idx)=>{ fw.forEach(p=>{ p.x += p.vx; p.y += p.vy; p.vy += 0.06; p.life--; }); fireworks[idx] = fw.filter(p=>p.life>0); }); fireworks = fireworks.filter(fw=>fw.length>0); }

  // -------------- Update loop --------------
  function update(dt){
    // timer
    if(!gameWon) timeElapsed += dt;
    document.getElementById('timeValue').innerText = timeElapsed.toFixed(1);
    document.getElementById('scoreValue').innerText = score;

    // input
    const left = keys['ArrowLeft'] || keys['KeyA'];
    const right = keys['ArrowRight'] || keys['KeyD'];
    const up = keys['ArrowUp'] || keys['Space'] || keys['KeyW'];

    if(left) player.vx = -player.speed; else if(right) player.vx = player.speed; else player.vx = 0;

    // gravity
    player.vy += 0.45;
    player.x += player.vx * dt * 60/16;
    player.y += player.vy * dt * 60/16;

    // simple world bounds
    if(player.x < 0) player.x = 0; if(player.x + player.w > floor.width - 20) player.x = floor.width - 20 - player.w;

    // moving platforms update
    movingPlatforms.forEach(p => { p.x = p.ox + Math.sin(timeElapsed * p.speed) * p.range; p.y = p.oy; });

    // move letterGroups slightly (gentle bobbing horizontally) to act as moving platforms
    letterGroups.forEach((r,i) => {
      const wobble = Math.sin(timeElapsed * 0.6 + i * 0.4) * 8; // small horizontal shift
      r.x = r.ox + wobble;
    });

    // collision detection
    player.grounded = false;
    const pbox = {x: player.x, y: player.y, width: player.w, height: player.h};
    const worldBodies = [floor, ...letterGroups, ...movingPlatforms];
    for(const b of worldBodies){
      if(rectsCollide(pbox, b)){
        const overlapX = Math.min(pbox.x + pbox.width - b.x, b.x + b.width - pbox.x);
        const overlapY = Math.min(pbox.y + pbox.height - b.y, b.y + b.height - pbox.y);
        if(overlapY < overlapX){
          if(pbox.y < b.y){ // landed on top
            player.y = b.y - player.h; player.vy = 0; player.grounded = true; player.jumpsUsed = 0; // reset jumps
          } else { // hit head
            player.y = b.y + b.height; player.vy = 0;
          }
        } else {
          if(pbox.x < b.x) player.x = b.x - player.w; else player.x = b.x + b.width;
        }
      }
    }

    // jumping with double jump
    if(up){
      if(player.grounded){ player.vy = player.jumpPower; player.grounded=false; player.jumpsUsed = 1; }
      else if(player.jumpsUsed > 0 && player.jumpsUsed < player.maxJumps){ player.vy = player.jumpPower; player.jumpsUsed++; }
    }

    // enemies movement & collision
    for(const e of enemies){
      e.x += e.vx * dt * 60/16;
      if(e.x < e.left) { e.x = e.left; e.vx *= -1; }
      if(e.x + e.w > e.right) { e.x = e.right - e.w; e.vx *= -1; }
      // collision with player -> restart
      if(rectsCollide({x:player.x,y:player.y,width:player.w,height:player.h}, {x:e.x,y:e.y,width:e.w,height:e.h})){
        // quick flash / small delay and reset
        restartOnDeath();
      }
    }

    // check collectibles overlap (simple) - none yet, but score can be incremented by touching letters
    // reward landing on letter pieces
    letterGroups.forEach(r => {
      if(rectsCollide(pbox, r) && !gameWon){ score += 0; /* placeholder if you want points */ }
    });

    // check win
    if(!gameWon && player.x + player.w > endArea.x + 60){
      gameWon = true; showCake = true; playWinSound(); spawnConfetti(); createCakePattern(); spawn27Fireworks();
    }

    // update confetti
    confettiParticles.forEach(p=>{ p.x += p.vx; p.y += p.vy; p.vy += 0.05; p.r *= 0.999; });
    confettiParticles = confettiParticles.filter(p=> p.y < H + 40 && p.r > 0.6);

    // update fireworks
    updateFireworks();
  }

  function restartOnDeath(){
    // brief flash & reset
    score = Math.max(0, score-5);
    // play small death sound
    if(soundOn){ const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type='square'; o.frequency.value = 120; g.gain.value = 0.03; o.connect(g); g.connect(masterGain); o.start(); setTimeout(()=>{ try{o.stop();}catch(e){} },120); }
    resetGame();
  }

  // -------------- Drawing --------------
  let cakePattern = null;
  function createCakePattern(){
    const oc = document.createElement('canvas'); oc.width=64; oc.height=64; const octx = oc.getContext('2d');
    octx.fillStyle = '#fff3c4'; octx.fillRect(0,24,64,40);
    octx.fillStyle = '#c84dff'; octx.fillRect(8,8,48,16);
    octx.fillStyle = '#ff6b6b'; octx.fillRect(10,28,44,12);
    for(let i=0;i<4;i++){ octx.fillStyle='#fff'; octx.fillRect(12 + i*10,7,4,10); octx.fillStyle=['#ffcd3c','#ff6b6b','#6bc6ff','#8dffb2'][i%4]; octx.fillRect(12 + i*10,5,4,4); }
    cakePattern = ctx.createPattern(oc,'repeat');
  }

  function draw(){
    ctx.clearRect(0,0,W,H);

    // camera: simple - center around player x but clamp
    const camX = Math.max(0, Math.min(player.x - W/3, floor.width - W));

    // draw parallax layers
    parallax.forEach(layer => { ctx.save(); ctx.translate(-camX * layer.depth, 0); layer.draw(); ctx.restore(); });

    // draw letters (HEL L Y)
    ctx.save();
    letterGroups.forEach(r=>{
      if(gameWon && cakePattern) ctx.fillStyle = cakePattern;
      else ctx.fillStyle = baseLetterColor;
      ctx.fillRect(r.x - camX, r.y, r.width, r.height);
      ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.strokeRect(r.x - camX + 1, r.y + 1, r.width-2, r.height-2);
    });
    ctx.restore();

    // draw moving platforms
    movingPlatforms.forEach(p=>{
      ctx.fillStyle = '#86592d'; ctx.fillRect(p.x - camX, p.y, p.width, p.height);
      ctx.strokeStyle='rgba(0,0,0,0.12)'; ctx.strokeRect(p.x - camX, p.y, p.width, p.height);
    });

    // draw floor
    ctx.fillStyle = '#3E2B1F'; ctx.fillRect(0, floor.y, W, floor.height);

    // end flag
    ctx.fillStyle = '#ffffff'; ctx.fillRect(endArea.x - camX + 20, 80, 8, 120);
    ctx.fillStyle = '#ff3b3b'; ctx.beginPath(); ctx.moveTo(endArea.x - camX + 28, 96); ctx.lineTo(endArea.x - camX + 68, 112); ctx.lineTo(endArea.x - camX + 28, 130); ctx.closePath(); ctx.fill();

    // draw enemies
    enemies.forEach(e=>{
      ctx.fillStyle = '#b22222'; ctx.fillRect(e.x - camX, e.y, e.w, e.h);
      ctx.fillStyle='rgba(0,0,0,0.12)'; ctx.fillRect(e.x - camX, e.y + e.h - 4, e.w, 3);
    });

    // draw player
    if(player.spriteLoaded && player.sprite){ ctx.drawImage(player.sprite, player.x - camX, player.y, player.w, player.h); }
    else { ctx.fillStyle = '#1b9aaa'; ctx.fillRect(player.x - camX, player.y, player.w, player.h); ctx.fillStyle = '#144'; ctx.fillRect(player.x - camX + 6, player.y + 8, 16, 10); }

    // draw fireworks and confetti
    fireworks.forEach(fw => fw.forEach(p=>{ ctx.fillStyle = p.c; ctx.fillRect(p.x - camX, p.y, 3, 3); }));
    confettiParticles.forEach(p=>{ ctx.fillStyle = p.c; ctx.beginPath(); ctx.arc(p.x - camX, p.y, p.r, 0, Math.PI*2); ctx.fill(); });

    // HUD text on canvas
    ctx.fillStyle = '#222'; ctx.font = '14px sans-serif'; ctx.fillText('Score: ' + score, 12, 22);

    // win overlay
    if(gameWon){ ctx.save(); ctx.font = 'bold 80px serif'; ctx.textAlign = 'center'; ctx.fillStyle = '#fff'; ctx.fillText('HAPPY BIRTHDAY', startX + 1020 - camX, baseY - 80); ctx.fillText('HELLY üòÄ', startX + 1020 - camX, baseY + 90); ctx.restore(); if(showCake) drawCake(endX + 90 - camX, 160, 140, 100); }
  }

  // parallax draw helpers
  function drawFarMountains(){ ctx.fillStyle='#5b8b8f'; ctx.beginPath(); ctx.moveTo(0,H); ctx.lineTo(120,200); ctx.lineTo(280,280); ctx.lineTo(460,180); ctx.lineTo(720,260); ctx.lineTo(960,200); ctx.lineTo(960,H); ctx.closePath(); ctx.fill(); }
  function drawNearHills(){ ctx.fillStyle='#6bbf65'; ctx.beginPath(); ctx.moveTo(0,H-80); ctx.quadraticCurveTo(240,H-200,480,H-80); ctx.quadraticCurveTo(720,H+10,960,H-80); ctx.lineTo(960,H); ctx.lineTo(0,H); ctx.closePath(); ctx.fill(); }
  function drawBushes(){ ctx.fillStyle='#3b8b3b'; for(let i=0;i<12;i++){ const x = i*120; ctx.beginPath(); ctx.ellipse(x+40, H-70, 40, 22, 0, 0, Math.PI*2); ctx.fill(); } }

  function drawCake(x,y,w,h){ ctx.save(); ctx.fillStyle='#f9e0c4'; ctx.fillRect(x+10,y+h*0.3,w-20,h*0.6); ctx.fillStyle='#d54d9b'; ctx.fillRect(x+10,y+h*0.12,w-20,h*0.22); for(let i=0;i<4;i++){ const cx = x + 25 + i*(w-50)/3; ctx.fillStyle='#fff'; ctx.fillRect(cx, y+8, 6, 22); ctx.fillStyle=['#ffcd3c','#ff6b6b','#6bc6ff','#8dffb2'][i%4]; ctx.fillRect(cx, y+4, 6, 6); } ctx.fillStyle='#222'; ctx.font='14px serif'; ctx.textAlign='center'; ctx.fillText('Make a wish!', x + w/2, y + h*0.6 + 6); ctx.restore(); }

  // -------------- Loop --------------
  let last = performance.now();
  function loop(now){ const dt = Math.min(1/30, (now - last)/1000); last = now; update(dt); draw(); requestAnimationFrame(loop); }
  resetGame(); requestAnimationFrame(loop);

  // ensure audio started by user gesture
  function ensureAudioStarted(){ if(audioCtx.state === 'suspended') audioCtx.resume(); }
  ['click','keydown','touchstart'].forEach(ev=> window.addEventListener(ev, ensureAudioStarted, {once:true}));

  // expose simple API
  window.hellyGame = { reset: resetGame, changeSprite: changePlayerSprite, toggleSound: ()=>{ soundOn = !soundOn; if(soundOn) startBackgroundMusic(); else stopBackgroundMusic(); } };

})();
</script>
</body>
</html>
